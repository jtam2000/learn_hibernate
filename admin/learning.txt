Learning summary for JPA relationships:
    [one-to-one]
            [unidirection]
                [option 1]:
                    in the source: (source = InvestmentUser.class)
                       InvestmentUser:
                        @OneToOne(cascade = ALL)  //required
                        @JoinColumn(name = "fk_acct_id")  //optinal
                        private InvestmentAccount account;  //source field
                    ..
                    in the target:
                        <..nothing..>
                    ..
                    database artifacts generated by the [@OneToOne] annotation:
                        1. a table for the source entity, table has a column for the fk to the target
                            .. for example column : "fk_acct_id"
                        2. a table for the target entity
                            .. normal table with its own primary key(if defined in the target POJO class)
                    ...
                [option 2]: using @JoinTable annotation:
                    in the source:
                       @OneToOne(cascade = ALL)
                         @JoinTable(
                                    name = "JOIN_BiInvestmentUser_BiInvestmentAcct",
                                    ...
                                    joinColumns = {@JoinColumn(name = "user_id_fk")},
                                    inverseJoinColumns = {@JoinColumn(name = "acct_id_fk")}
                          )
                          private BiInvestmentAccount account;
            [bidirection]

    one-to-many
    many-to-one
    many-to-many

Learning: Bidrectional One-To-Many:
            https://www.logicbig.com/tutorials/java-ee-tutorial/jpa/one-to-many-bidirectional.html
            -In bidirectional one-to-many/many-to-one relationship, the target side has a reference back to the
            source entity as well.
            -The annotation @OneToMany is used on the side which has the collection reference.
            -The annotation @ManyToOne is used on the side which has the single-valued back reference.
            -We must use 'mappedBy' element of the @OneToMany annotations to specify that the corresponding table
            will be the parent table. In other words the other side (which has @ManyToOne) will be the foreign-key
            table (child table).
            -The value of 'mappedBy' element should be the name of the reference variable used in the other class's
             back reference.
            -The side which has 'mappedBy' specified, will be the target entity of the relationship and corresponding
             table will be the parent of the relationship .
            -The side which doesn't have 'mappedBy' element will be the source (owner) and the corresponding table will
             be the child of the relationship, i.e. it will have the foreign key column.
            -On the owner side, we can also use @JoinColumn, whose one of the purposes is to specify a foreign key
            column name instead of relying on the default name.

Learning: to get from Entity to class:
        Set<EntityType<?>> x = em.getMetamodel().getEntities();
        for (EntityType<?> entity : x) {
            Class<?> type = entity.getJavaType();
            System.out.println("Entity name: " + entity + ", Class: " + entity.getJavaType());
        }

LEarning: good jpa tutorial website, not easy to google: https://www.logicbig.com/tutorials/java-ee-tutorial/jpa.html

Learning: Bidirectional: Bidirectional relationships must follow these rules.
    -The inverse side of a bidirectional relationship must refer to its owning side by using the mappedBy element of
    the @OneToOne, @OneToMany, or @ManyToMany annotation. The mappedBy element designates the property or field in the
    entity that is the owner of the relationship.
    ...
    -The many side of many-to-one bidirectional relationships must not define the mappedBy element. The many side is
    always the owning side of the relationship.
    ...
    -For one-to-one bidirectional relationships, the owning side corresponds to the side that contains the corresponding
     foreign key.
     ...
    -For many-to-many bidirectional relationships, either side may be the owning side.

Learning:
    In JPA we use the @ManyToMany annotation to model many-to-many relationships. This type of relationship can be
    unidirectional or bidirectional:
    ...
    In a unidirectional relationship only one entity in the relationship points the other.
    In a bidirectional relationship both entities point to each other.


Learning: JPA one-to-one relationship:
    0. you need to do 3 things:
        a. Annotate @OneToOne in the field within the root entity, you don't need to do anything in the dependent entity
        b. must fill in  Cascade attribute in the  @OneToOne, for example:  @OneToOne(cascade = ALL)
        c. write a public/protected no-arg constructor to the root and dependent entities (to be JPA-spec compliant)
    1. Default is not to cascade persist the linked sub-element, you have annotate @OneToOne with [cascade] parameter
        @OneToOne(cascade = {ALL})
    2. To have the cascade take effect, you have to update the root entity within a transaction. But don't
         do a delete of the root entity table, that is a database action, it will not trigger the JPA cascade event
    3. with Hibernate as JPA provider, you don't need to provide a no-arg constructor, but because the JPA spec
        saids it is a requirement, my code will create a [Protected] version of no-arg constructure, this way
        it is jpa-spec compliant and user of the entity can not instantiate it directly(if that is what is desired)
    4. Setter and Getter for entities are not required for JPA
    5. the root entity is defaulted to have an foreign key into the dependent entity, that foreign key column
        can be configure like this example: (the foreign key column is created as "acct_id")
        @JoinColumn(name = "acct_id")
        private InvestmentAccount account;
    6. there is also orphanRemoval, like this:
          @OneToOne(cascade = ALL, orphanRemoval = true)
    7. in Create of Crud: after the create (which is just transaction wrapped in persist()). the Primary key
        is filled with whatever was autogenerated in the db. so if you want to find by PrimaryKey after the create,
        you can look at the in-memory version of the entity and use the PrimaryKey. Apparently JPA/Hibernate fills
        in the primary key in once it has been persisted.


LEARNING: JPA is configuration by Exception, if default behavior is not correct, we have to configure an exception
    to suit what we want.
    When it comes to mapping btwn relationship btwn entities in JPA:, there are 4 types
        1. @OneToOne
        2. @OneToMany
        3. @ManyToOne
        4. @ManyToMany
    relations btwn  entities has 2 dimensions: Direction and Cardinality(oneToMany is cardinarlity)
    ----
    [Default JPA Database Cardinality Mapping strategy] is as follows:
    @OneToOne   --> use Join Columns
    @ManyToOne  --> use Join Columns  (Rule: basically anything that ends with ONe is Join Column)
    ----
    @OneToMany  --> use Join Table   (Rule: basically anything that ends with Many is Join Table)
    @ManyToMany --> use Join Table
    -----
    [Default JPA Fetching]   (rule is if it ends in One, then eager, if ends in Many: then Lazy
    @OneToOne   -> eager
    @ManyToOne  -> eager
    @OneToMany  -> Lazy
    @ManyToMany -> Lazy



Learning: you can map two tables in 2 methods: using foreign keys in each table, 2) use a sparate linking table that
    links one table's primary key to another table's primary key.

Learning: composite keys in jpa:
    In order to define the composite primary keys, we should follow some rules:
    The [composite primary key class] must be public:
    It must have a no-arg constructor
    It must define equals() and hashCode() methods
    It must be Serializable

LEARNING: EntityManager main methods: persist, remove, find,  merge. Merge is a different animal from CRUD.
    merge() is only required when you have a detached copy of a persistence object.
    A detached object is one that was read through a different EntityManager
    (or in a different transaction in a JEE managed EntityManager), or one that was cloned, or serialized
    Example:
    EntityManager em = createEntityManager();
    Employee detached = em.find(Employee.class, id);
    em.close();
    ...
    em = createEntityManager();
    em.getTransaction().begin();
        Employee managed = em.merge(detached);
    em.getTransaction().commit();
    ...
    there is no EntityManger method to update to entity object, you just have to update the Java Object itself
    and then wrap the set/update methods within a transaction

LEARNING: clear() will detached all object in the current EntityManager context
        Clearing is also important on large batch jobs, even if they occur in a single transaction. T
        he batch job can be slit into smaller batches within the same transaction and clear can be
        called in between each batch to avoid the persistence context from getting too big.

Learning: An EntityManger contains the Persistence context for a managed object.
    JPA defines 2 states of persistent object: managed vs detached
    managed: managed by an EntityManager
    detached: not managed by an entity Manager
    for a detached object, calling persist(object)  or merge(object) will make the object managed
    call clear(), detach(), remove() after a flush() or commit() will change  the object state to unmanaged


Learning: Embedded entity are entities that associated with an @Entity

Learning: an object should only be managed by 1 EntityManager, otherwise confusion.
    A managed object should only ever reference other managed objects,
    and a detached object should only reference other detached objects.

LEARNING: DAO vs Repository: DAO is data persistence layer. Repository is collection-level
    info closer to teh business-logic layer. Repository may use DAO to persist the info


LEARNING: JPA Bootstrapping: should always use JPA conformant bootstrapping instead
    of Hibernate
    EntityManagerFactory produces EntityManager
    Approach 1: EE approach -> a container injects persistence context into application
    Approach 2: SE Approach -> everything else (Application-bootstrapping)
    _
    Approach 1: (Container-bootstrapping)
        1. each named Persistence Unit defined in META-INF/persistence.xml config
            mark an object as EntityManagerFactory using @PersistenceUnit

LEARNING: -3 Inheritance Mapping strategy
    1. table per hierarchy (1 table for entire inheritance tree), requires:
       1.  @Inheritance(strategy=InheritanceType.SINGLE_TABLE) on parent class
       2.  @DiscriminatorColumn on parent class to say what column in db is added to distinguish
            (on parent class: @DiscriminatorColumn(name="type",discriminatorType=DiscriminatorType.STRING)
       3. @DiscriminatorValue on all classes (parent and child)
            ex: @DiscriminatorValue(value="employee")
    2. table per concrete class, requires:  (duplicate parent columns in subclass tables)
        1. @Inheritance(strategy = InheritanceType.TABLE_PER_CLASS) in parent class only
        2. @AttributeOverrides in subclasses (attributes you want to inherit from the parent)
            these columns from the parent class are added(inherited) to columns of the subclass
            example:
                    @AttributeOverrides({
                        @AttributeOverride(name="id", column=@Column(name="id")),
                        @AttributeOverride(name="name", column=@Column(name="name"))
                    })
        each inherited class need to use @DiscriminatorValue("classColumnUnique")
    3. Most elegant/preferred: table per Subclass, requires
        1. @Inheritance(strategy=InheritanceType.JOINED) in the parent class
        2. @PrimaryKeyJoinColumn annotation in the subclasses, you don't need it in the parent class
            example: @PrimaryKeyJoinColumn(name="ID")  : the parent column ID is joined with this subclass
    for all three method: you need to add these classes to the config file


    Summary: required:
        1. parent class: You put @Inheritance(strategy=?) , @DiscriminatorColumn for table per hierarchy
        2. child class: @DiscriminatorValue(TPH), @AttributeOverrides(tpcc), @PrimaryKeyJoinColumn(TPS)
        3. parent and child class: added to Config file

LEARNING: put to practice: Associations describe
                 how two or more entities form a relationship based on a database joining semantics.
             -4 Collection Mappings
             1. OneToMany
                 one the collection field:
                 @OneToMany(cascade = CascadeType.ALL)
                 @JoinColumn(name="qid")
                 @OrderColumn(name="type")
             2. ManyToOne
                 the target Object that many are associated with: like one company address used by Many Employees
                 this is annotated on top of Address
                   @ManyToOne(cascade=CascadeType.ALL)
                 on the many objects that to the Single Object
                   @OneToOne(cascade=CascadeType.ALL)
             3. OneToOne
                 on both classes being mapped
                 @OneToOne(targetEntity=Address.class,cascade=CascadeType.ALL)
                 @OneToOne(targetEntity=Employee.class)
             4 ManyToMany
                 on one of the objects:
                 @ManyToMany(targetEntity = Answer.class, cascade = { CascadeType.ALL })
                 @JoinTable(name = "q_ans1123",
                             joinColumns = { @JoinColumn(name = "q_id") },
                             inverseJoinColumns = { @JoinColumn(name = "ans_id") })


LEARNING: Spring framework,
    Spring has 3 main components that are exposed through the use of Annotations:
        -Controller Annotations (Route Request and response for business logic processing) (@Controller)
        -Service Annotations  (business logic processing - actions ) (@Service)
        -Repository Annotations (@Repository - data persistence with database)

LEARNING: JPQL is NOT SQL. JPQL is query language written from the perspective of Java Objects,
            whereas SQL is written from a database object perspective
            SQL: "select * from goals", JPQL: "select g from Goals g"

LEARNING: JPA is a specification for accessing, persisting, and managing data between Java Objects and a relational
            database. It has a sql-like language call JPQL - java persistence query language

LEARNING: HQL is super set of JPQL
            A JPQL query is always a valid HQL query, the reverse is not true, however.

LEARNING: Hibernate is used to map Java Objects to Relational databases. There is only a mediocre solution because of
    fundamental Object-Relational Impedance Mismatch principal.  There will always be gaps in the mapping that leads
    to less elegant solutions.
    nevertheless it is used in the industry, thus I must be familiar with this technique. and learn-ing should continue.
    There are competing solutions such using NoSql database.  As part of training, I should see how using NoSql can
    solve this Object-to-Persistence problem.

LEARNING:  In Brief: Advantages and Disadvantages of Using ORM
     FOR:
         -let the developer think in terms of objects rather than tables
         -no need to write SQL code
         -many advanced features like lazy loading
         -database independent: No need to write code specific to a particular database
         -reduces code and allows developers to focus on their business logic, rather than complex database queries
         -various ORMs provide a rich query interface
     AGAINST:
         -complex (because they handle a bidirectional mapping). Their complexity implies a grueling learn-ing curve â€“
         they have a special query language which developers have to learn
         -provides only a leaky abstraction over a relational data store
         -usually systems using an ORM perform badly (due to naive interactions with the underlying database)
         -ORM, by adding a layer of abstraction, speeds up the development but adds overhead to the application

LEARNING: ORM only provides a **leaky*** abstraction over a relational data store, meaning it is not a completion
            solution
          usually systems using an ORM perform badly (due to naive interactions with the underlying database)


LEARNING: When to USE ORM
        SAY YES TO ORM:
          it is intended for OLTP applications  (transaction orientated, small batches)
        SAY NO TO ORM:
          not intended for batch processing (large set of data being transacted, like bulk transformations)
          not recommended where there is a need to perform huge analysis

LEARNING: NoSql
    problem is that NoSql is not standardized, you have to learn new language with different vendors. Where as SQL
    is standardized across the industry
    NoSql is usually distributed Database, make it difficult to integrate to simple apps
    Most NoSql don't need to support transactions
