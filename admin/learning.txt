Learning: composite keys in jpa:
    In order to define the composite primary keys, we should follow some rules:
    The [composite primary key class] must be public:
    It must have a no-arg constructor
    It must define equals() and hashCode() methods
    It must be Serializable

LEARNING: EntityManager main methods: persist, remove, find,  merge. Merge is a different animal from CRUD.
    merge() is only required when you have a detached copy of a persistence object.
    A detached object is one that was read through a different EntityManager
    (or in a different transaction in a JEE managed EntityManager), or one that was cloned, or serialized
    Example:
    EntityManager em = createEntityManager();
    Employee detached = em.find(Employee.class, id);
    em.close();
    ...
    em = createEntityManager();
    em.getTransaction().begin();
        Employee managed = em.merge(detached);
    em.getTransaction().commit();
    ...
    there is no EntityManger method to update to entity object, you just have to update the Java Object itself
    and then wrap the set/update methods within a transaction

LEARNING: clear() will detached all object in the current EntityManager context
        Clearing is also important on large batch jobs, even if they occur in a single transaction. T
        he batch job can be slit into smaller batches within the same transaction and clear can be
        called in between each batch to avoid the persistence context from getting too big.

Learning: An EntityManger contains the Persistence context for a managed object.
    JPA defines 2 states of persistent object: managed vs detached
    managed: managed by an EntityManager
    detached: not managed by an entity Manager
    for a detached object, calling persist(object)  or merge(object) will make the object managed
    call clear(), detach(), remove() after a flush() or commit() will change  the object state to unmanaged


Learning: Embedded entity are entities that associated with an @Entity

Learning: an object should only be managed by 1 EntityManager, otherwise confusion.
    A managed object should only ever reference other managed objects,
    and a detached object should only reference other detached objects.

LEARNING: DAO vs Repository: DAO is data persistence layer. Repository is collection-level
info closer to teh business-logic layer. Repository may use DAO to persist the info


LEARNING: JPA Bootstrapping: should always use JPA conformant bootstrapping instead
    of Hibernate
    EntityManagerFactory produces EntityManager
    Approach 1: EE approach -> a container injects persistence context into application
    Approach 2: SE Approach -> everything else (Application-bootstrapping)
    _
    Approach 1: (Container-bootstrapping)
        1. each named Persistence Unit defined in META-INF/persistence.xml config
            mark an object as EntityManagerFactory using @PersistenceUnit

LEARNING: -3 Inheritance Mapping strategy
    1. table per hierarchy (1 table for entire inheritance tree), requires:
       1.  @Inheritance(strategy=InheritanceType.SINGLE_TABLE) on parent class
       2.  @DiscriminatorColumn on parent class to say what column in db is added to distinguish
            (on parent class: @DiscriminatorColumn(name="type",discriminatorType=DiscriminatorType.STRING)
       3. @DiscriminatorValue on all classes (parent and child)
            ex: @DiscriminatorValue(value="employee")
    2. table per concrete class, requires:  (duplicate parent columns in subclass tables)
        1. @Inheritance(strategy = InheritanceType.TABLE_PER_CLASS) in parent class only
        2. @AttributeOverrides in subclasses (attributes you want to inherit from the parent)
            these columns from the parent class are added(inherited) to columns of the subclass
            example:
                    @AttributeOverrides({
                        @AttributeOverride(name="id", column=@Column(name="id")),
                        @AttributeOverride(name="name", column=@Column(name="name"))
                    })
        each inherited class need to use @DiscriminatorValue("classColumnUnique")
    3. Most elegant/preferred: table per Subclass, requires
        1. @Inheritance(strategy=InheritanceType.JOINED) in the parent class
        2. @PrimaryKeyJoinColumn annotation in the subclasses, you don't need it in the parent class
            example: @PrimaryKeyJoinColumn(name="ID")  : the parent column ID is joined with this subclass
    for all three method: you need to add these classes to the config file


    Summary: required:
        1. parent class: You put @Inheritance(strategy=?) , @DiscriminatorColumn for table per hierarchy
        2. child class: @DiscriminatorValue(TPH), @AttributeOverrides(tpcc), @PrimaryKeyJoinColumn(TPS)
        3. parent and child class: added to Config file

LEARNING: put to practice: Associations describe
                 how two or more entities form a relationship based on a database joining semantics.
             -4 Collection Mappings
             1. OneToMany
                 one the collection field:
                 @OneToMany(cascade = CascadeType.ALL)
                 @JoinColumn(name="qid")
                 @OrderColumn(name="type")
             2. ManyToOne
                 the target Object that many are associated with: like one company address used by Many Employees
                 this is annotated on top of Address
                   @ManyToOne(cascade=CascadeType.ALL)
                 on the many objects that to the Single Object
                   @OneToOne(cascade=CascadeType.ALL)
             3. OneToOne
                 on both classes being mapped
                 @OneToOne(targetEntity=Address.class,cascade=CascadeType.ALL)
                 @OneToOne(targetEntity=Employee.class)
             4 ManyToMany
                 on one of the objects:
                 @ManyToMany(targetEntity = Answer.class, cascade = { CascadeType.ALL })
                 @JoinTable(name = "q_ans1123",
                             joinColumns = { @JoinColumn(name = "q_id") },
                             inverseJoinColumns = { @JoinColumn(name = "ans_id") })


LEARNING: Spring framework,
    Spring has 3 main components that are exposed through the use of Annotations:
        -Controller Annotations (Route Request and response for business logic processing) (@Controller)
        -Service Annotations  (business logic processing - actions ) (@Service)
        -Repository Annotations (@Repository - data persistence with database)

LEARNING: JPQL is NOT SQL. JPQL is query language written from the perspective of Java Objects,
            whereas SQL is written from a database object perspective
            SQL: "select * from goals", JPQL: "select g from Goals g"

LEARNING: JPA is a specification for accessing, persisting, and managing data between Java Objects and a relational
            database. It has a sql-like language call JPQL - java persistence query language

LEARNING: HQL is super set of JPQL
            A JPQL query is always a valid HQL query, the reverse is not true, however.

LEARNING: Hibernate is used to map Java Objects to Relational databases. There is only a mediocre solution because of
    fundamental Object-Relational Impedance Mismatch principal.  There will always be gaps in the mapping that leads
    to less elegant solutions.
    nevertheless it is used in the industry, thus I must be familiar with this technique. and learn-ing should continue.
    There are competing solutions such using NoSql database.  As part of training, I should see how using NoSql can
    solve this Object-to-Persistence problem.

LEARNING:  In Brief: Advantages and Disadvantages of Using ORM
     FOR:
         -let the developer think in terms of objects rather than tables
         -no need to write SQL code
         -many advanced features like lazy loading
         -database independent: No need to write code specific to a particular database
         -reduces code and allows developers to focus on their business logic, rather than complex database queries
         -various ORMs provide a rich query interface
     AGAINST:
         -complex (because they handle a bidirectional mapping). Their complexity implies a grueling learn-ing curve â€“
         they have a special query language which developers have to learn
         -provides only a leaky abstraction over a relational data store
         -usually systems using an ORM perform badly (due to naive interactions with the underlying database)
         -ORM, by adding a layer of abstraction, speeds up the development but adds overhead to the application

LEARNING: ORM only provides a **leaky*** abstraction over a relational data store, meaning it is not a completion
            solution
          usually systems using an ORM perform badly (due to naive interactions with the underlying database)


LEARNING: When to USE ORM
        SAY YES TO ORM:
          it is intended for OLTP applications  (transaction orientated, small batches)
        SAY NO TO ORM:
          not intended for batch processing (large set of data being transacted, like bulk transformations)
          not recommended where there is a need to perform huge analysis

LEARNING: NoSql
    problem is that NoSql is not standardized, you have to learn new language with different vendors. Where as SQL
    is standardized across the industry
    NoSql is usually distributed Database, make it difficult to integrate to simple apps
    Most NoSql don't need to support transactions
