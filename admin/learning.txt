LEARNING: JPQL: The query is based on Entities, not on tables not SQL.
    there are 2 mandatory parts for Select: Select and From, the from clause must refer to an @Entity object, not
    a database object

LEARNING: There is Query object and there is TypeQuery, the first returns Objects, where as TypedQuery
    pass in object.class so it will return query results based on Object.class passed into the TypedQuery

Learning: JPA inheritance
    jpa offers maps of java inheritance into table object models in 3 strategies:
      1. single table per class [is the DEFAULT JPA inheritance strategy if you don't annotation]
      2. Joined subclass
      3. table per concrete class

LEARNING: [Single-Table-Per-Class] Strategy: [NOT GOOD Strategy in my opinion, bad db design and brittle]
    the entire hierarchy's fields are mapped onto a single table, with a column called "DTYPE" which
    serves as a unique key for an object in the inheritance hierarchy :
    ...
    example Inheritance Hierarchy: both ObjectB, ObjectC inherits from Object A
        ...
            ObjectA:
                int FieldA;
                String FieldB;
            ObjectB: extends Object A
                int FieldC;
                int FieldD;
            ObjectC: extends Object A
                int FieldF;
    ...
    ... Table Created to store the hierarchy:
    ..
    Table SingleTable:
        DTYPE varChar(31)   //new column auto-generated by JPA supplier, mapped to Java String type, by default
        int FieldA;         //from ObjectA
        String FieldB;      //from ObjectA
        int fieldC;         //from ObjectB
        int fieldD;         //from ObjectB
        int FieldF;         //from ObjectF;
    ...
    //Issues with Single-Table strategy:
    1. If class changes, data tables changes (add/delete columns), this is more easy for data migration
    2. attributes of root classes is static, problems of attributes difference btwn parent and child class
    3. for example: some root attributes need can only be Nullable or NonNullable, but can not accommodate child
        classes that may need to have different root attributes.

LEARNING: [Joined-Sub-class] strategy:  [THIS IS THE BEST DB-design Strategy: mostly will use this in practice]
   - each objects in the hierarchy has its own database tables
    -the child classes need to join with the parent table to get full data
    -parent has DTYPE column

LEARNING: [Table-per-concrete-class] strategy: (LEARNING NOTE: database denormalizes the Join-sub-class strategy)
   - same as [Joined-Sub-class], PLUS:
   - the parent attributes are repeated in the child class tables
   - parent does NOT have DTYPE column

LEARNING: Annotating Inheritance hierarchy:
    ...
    //for parent class
    @Entity
    @Inheritance(strategy = JOINED) // JOINED, TABLE_PER_CLASS, SINGLE_TABLE, annotate on the root table
    @DiscriminatorColumn(name ="className", discriminatorType=STRING) //annotates DTYPE
    @DiscriminatorValue("MyParentClass")
    public class MyParentClass {...}
   ...
   //for child class 1
    @Entity
    @DiscriminatorValue("Children1")
    public class ChildrenClass1 {...}
   ...
   //for child class 2
    @Entity
    @DiscriminatorValue("Children2")
    public class ChildrenClass2 {...}

LEARNING: @MappedSuperclass
        @Entity does not have to inherit from an @Entity, it can inherit from any class, including abstract class
        or jpa transient class(not tracked by JPA)
        you can have a @MappedSuperclass on a parent class to indicate that the class will share data with
        the child class, but the data WILL NOT BE PERSISTED in the database (as parent tables) (it can NOT be queried
        via EntityManager)
        for example:
            @MappedSuperclass
            public class Parent{
                @ID @GeneratedValue
                protected long iD;
                protected String value ; //these attributes will NOT persist into DB
                ...
            }
           ..
           @Entity
           public class Child: extends parent {
                @ID
                int childValue; // these attributes WILL persist into db
           }
        //in this case, only one table is create: Child, Parent table WILL NOT BE CREATED


Learning summary for JPA relationships:
    [one-to-one]: 2 or 3tables (3 table using @JoinTable)
            [uni-direction]
                [option 1]: [TWO Tables created]
                    in the source: (source = InvestmentUser.class)
                       InvestmentUser:
                        @OneToOne(cascade = ALL)  //required
                        @JoinColumn(name = "fk_acct_id")  //optional
                        private InvestmentAccount account;  //source field, but target class  !!important difference
                    ..
                    in the target:
                         target class annotated as @Entity
                    ..
                    database artifacts generated by the [@OneToOne] annotation:
                        1. a table for the source entity, table has a column for the fk to the target
                            .. for example column : "fk_acct_id"
                        2. a table for the target entity
                            .. normal table with its own primary key(if defined in the target POJO class)
                    ...
                [option 2]: using @JoinTable annotation: [THREE tables created]
                    in the source: (source = InvestmentUser.class)
                       @OneToOne(cascade = ALL)
                         @JoinTable(
                                    name = "JOIN_BiInvestmentUser_BiInvestmentAcct",
                                    ...
                                    joinColumns = {@JoinColumn(name = "user_id_fk")},
                                    inverseJoinColumns = {@JoinColumn(name = "acct_id_fk")}
                          )
                          private BiInvestmentAccount account //source field, but target class  !!important difference
                     ..
                     in the target:
                         target class annotated as @Entity
                     ..
                     database artifacts generated by the [@OneToOne] annotation:
                         1. a table for the source entity, table has a column for the fk to the target
                             .. for example column : "fk_acct_id"
                         2. a table for the target entity
                             .. normal table with its own primary key(if defined in the target POJO class)
                             ...
                         3. A join table (defaulted, or named by @JoinTable attribute): has FK from source and target
                            table
                     ...
            [bi-direction]: [TWO tables created]
                in the source: (source = InvestmentUser.class)  (THIS IS SAME as UNI-DIRECTION 1:1 option 1
                   InvestmentUser:
                    @OneToOne(cascade = ALL)  //required
                    @JoinColumn(name = "fk_acct_id")  //optional
                    private InvestmentAccount account;  //source field, but target class  !!important difference
                ..
                in the target:
                ...
                1. target class needs to be annotated as @Entity AND...
                2. @OneToOne(mappedBy = "account") //LEARNING: value of mappedBy = VARIABLE name of the owner BiInvestmentUser
                   private BiInvestmentUser user;
                   ...
                        database artifacts generated by the [@OneToOne] annotation:
                            1. a table for the source entity, table has a column for the fk to the target
                                .. for example column : "fk_acct_id"
                            2. a table for the target entity
                                .. normal table with its own primary key(if pk is defined in the target POJO class)
                        ...

    [one-to-many] always 3 tables, join table can be auto-generated or created by @JoinTable Annotation
            [uni-directional]: 3 Tables
             LEARNING:
                in the source:
                    @OneToMany(cascade = ALL)
                    private List<PostageStamp> collection = new LinkedList<>();
                ...
                in the target:
                 target class annotated as @Entity
               ...
               Database Effect:
                   1. a table for the source entity, table has a column for the fk to the target
                           .. for example column : "fk_acct_id"
                   2. a table for the target entity
                           .. normal table with its own primary key(if pk is defined in the target POJO class)
                   3. auto-generated join table btwn source table and target table, with 2 columns:
                     a) PK of the Source and b) PK of the Target

            [uni-directional, using Join-table]: 3 Tables
             LEARNING:
                in the source:
                    @OneToMany(cascade = ALL)
                    //LEARNING:
                    //  the join column in the [MANY] side
                    //  the inverseJoin column is the [ONE] side
                    @JoinTable(name = "JointTable1M_StampCollectionOneDirection",
                            joinColumns = {@JoinColumn(name = "fk_collection_id")},
                            inverseJoinColumns = {@JoinColumn(name = "fk_stamp_id")}
                    )
                    private final List<PostageStamp> collection = new LinkedList<>();
                ...
                in the target:
                 target class annotated as @Entity
               ...
               Database Effect:
                   1. a table for the source entity, table has a column for the fk to the target
                           .. for example column : "fk_acct_id"
                   2. a table for the target entity
                           .. normal table with its own primary key(if pk is defined in the target POJO class)
                   3. join table specified by @JointTable btwn source table and target table, with 2 columns:
                     a) PK of the Source and b) PK of the Target

            [bi-directional]: 3 tables
              LEARNING: To Do a Bi-directional One-To-Many, you need a  @OneToMany (on the target) AND
                        a @ManyToOne(on the source)
               ...
               [source]: PostageStamp.class:
                ...
                    @ManyToOne(cascade = ALL)
                    @JoinColumn(name = "FK_Collection_" + ID)  //specify the name of the FK column
                    private BiDirectionStampCollection keptInCollection;
                ...
               [target]: StampCollection.class
                    @OneToMany(mappedBy = "keptInCollection", cascade = ALL) //LEARNING: value of mappedBy = VARIABLE name of the owner PostageStamp
                   private List<PostageStamp> collection = new LinkedList<>();  //use Set not List, so collection element is unique

               Database Effect: 3 tables
                1. table for source
                2. table for target
                3. auto-generated mapping table with 2 columns PK from Source and PK from Target

    many-to-one: 2 tables
            [uni-directional] : 2 tables
                source:
                        @ManyToOne
                        @JoinColumn(name = COUNTRY_ID)
                        private PostalCountry country;

                target:
                         target class annotated as @Entity

                Database Effect: 2 tables

             [bi-directional]: one side of the  One-To-Many relationship(mirror image of One-To-Many)
                Database Effect: 3 tables, with an auto-generated mapping table

    many-to-many: 3 tables
            LEARNING:
            [using join-table]: 3 tables
            source:
                @ManyToMany(cascade = PERSIST)
                @JoinTable(
                        name = "jnStampToCollection",
                        joinColumns = {@JoinColumn(name = "StampID_FK")},
                        inverseJoinColumns = {@JoinColumn(name = "CollectionID_FK")}
                )
                private Set<MyStampCollection> collections=new HashSet<>();

            target:
                target class annotated as @Entity
            Database Effect: 3 tables
                1. source table
                2. target table
                3. Join Table created by @JoinTable Annotation on the source or the target

Learning: Bidirectional One-To-Many:
            https://www.logicbig.com/tutorials/java-ee-tutorial/jpa/one-to-many-bidirectional.html
            -In bidirectional one-to-many/many-to-one relationship, the target side has a reference back to the
            source entity as well.
            -The annotation @OneToMany is used on the side which has the collection reference.
            -The annotation @ManyToOne is used on the side which has the single-valued back reference.
            -We must use 'mappedBy' element of the @OneToMany annotations to specify that the corresponding table
            will be the parent table. In other words the other side (which has @ManyToOne) will be the foreign-key
            table (child table).
            -The value of 'mappedBy' element should be the name of the reference variable used in the other class's
             back reference.
            -The side which has 'mappedBy' specified, will be the target entity of the relationship and corresponding
             table will be the parent of the relationship .
            -The side which doesn't have 'mappedBy' element will be the source (owner) and the corresponding table will
             be the child of the relationship, i.e. it will have the foreign key column.
            -On the owner side, we can also use @JoinColumn, whose one of the purposes is to specify a foreign key
            column name instead of relying on the default name.

Learning: to get from Entity to class:
        Set<EntityType<?>> x = em.getMetamodel().getEntities();
        for (EntityType<?> entity : x) {
            Class<?> type = entity.getJavaType();
            System.out.println("Entity name: " + entity + ", Class: " + entity.getJavaType());
        }

LEarning: good jpa tutorial website, not easy to google: https://www.logicbig.com/tutorials/java-ee-tutorial/jpa.html

Learning: Bidirectional: Bidirectional relationships must follow these rules.
    -The inverse side of a bidirectional relationship must refer to its owning side by using the mappedBy element of
    the @OneToOne, @OneToMany, or @ManyToMany annotation. The mappedBy element designates the property or field in the
    entity that is the owner of the relationship.
    ...
    -The many side of many-to-one bidirectional relationships must not define the mappedBy element. The many side is
    always the owning side of the relationship.
    ...
    -For one-to-one bidirectional relationships, the owning side corresponds to the side that contains the corresponding
     foreign key.
     ...
    -For many-to-many bidirectional relationships, either side may be the owning side.

Learning:
    In JPA we use the @ManyToMany annotation to model many-to-many relationships. This type of relationship can be
    unidirectional or bidirectional:
    ...
    In a unidirectional relationship only one entity in the relationship points the other.
    In a bidirectional relationship both entities point to each other.


Learning: JPA one-to-one relationship:
    0. you need to do 3 things:
        a. Annotate @OneToOne in the field within the root entity, you don't need to do anything in the dependent entity
        b. must fill in  Cascade attribute in the  @OneToOne, for example:  @OneToOne(cascade = ALL)
        c. write a public/protected no-arg constructor to the root and dependent entities (to be JPA-spec compliant)
    1. Default is not to cascade persist the linked sub-element, you have annotate @OneToOne with [cascade] parameter
        @OneToOne(cascade = {ALL})
    2. To have the cascade take effect, you have to update the root entity within a transaction. But don't
         do a delete of the root entity table, that is a database action, it will not trigger the JPA cascade event
    3. with Hibernate as JPA provider, you don't need to provide a no-arg constructor, but because the JPA spec
        saids it is a requirement, my code will create a [Protected] version of no-arg constructure, this way
        it is jpa-spec compliant and user of the entity can not instantiate it directly(if that is what is desired)
    4. Setter and Getter for entities are not required for JPA
    5. the root entity is defaulted to have an foreign key into the dependent entity, that foreign key column
        can be configure like this example: (the foreign key column is created as "acct_id")
        @JoinColumn(name = "acct_id")
        private InvestmentAccount account;
    6. there is also orphanRemoval, like this:
          @OneToOne(cascade = ALL, orphanRemoval = true)
    7. in Create of Crud: after the create (which is just transaction wrapped in persist()). the Primary key
        is filled with whatever was autogenerated in the db. so if you want to find by PrimaryKey after the create,
        you can look at the in-memory version of the entity and use the PrimaryKey. Apparently JPA/Hibernate fills
        in the primary key in once it has been persisted.


LEARNING: JPA is configuration by Exception, if default behavior is not correct, we have to configure an exception
    to suit what we want.
    When it comes to mapping btwn relationship btwn entities in JPA:, there are 4 types
        1. @OneToOne
        2. @OneToMany
        3. @ManyToOne
        4. @ManyToMany
    relations btwn  entities has 2 dimensions: Direction and Cardinality(oneToMany is cardinarlity)
    ----
    [Default JPA Database Cardinality Mapping strategy] is as follows:
    @OneToOne   --> use Join Columns
    @ManyToOne  --> use Join Columns  (Rule: basically anything that ends with ONe is Join Column)
    ----
    @OneToMany  --> use Join Table   (Rule: basically anything that ends with Many is Join Table)
    @ManyToMany --> use Join Table
    -----
    [Default JPA Fetching]   (rule is if it ends in One, then eager, if ends in Many: then Lazy
    @OneToOne   -> eager
    @ManyToOne  -> eager
    @OneToMany  -> Lazy
    @ManyToMany -> Lazy



Learning: you can map two tables in 2 methods: using foreign keys in each table, 2) use a sparate linking table that
    links one table's primary key to another table's primary key.

Learning: composite keys in jpa:
    In order to define the composite primary keys, we should follow some rules:
    The [composite primary key class] must be public:
    It must have a no-arg constructor
    It must define equals() and hashCode() methods
    It must be Serializable

LEARNING: EntityManager main methods: persist, remove, find,  merge. Merge is a different animal from CRUD.
    merge() is only required when you have a detached copy of a persistence object.
    A detached object is one that was read through a different EntityManager
    (or in a different transaction in a JEE managed EntityManager), or one that was cloned, or serialized
    Example:
    EntityManager em = createEntityManager();
    Employee detached = em.find(Employee.class, id);
    em.close();
    ...
    em = createEntityManager();
    em.getTransaction().begin();
        Employee managed = em.merge(detached);
    em.getTransaction().commit();
    ...
    there is no EntityManger method to update to entity object, you just have to update the Java Object itself
    and then wrap the set/update methods within a transaction

LEARNING: clear() will detached all object in the current EntityManager context
        Clearing is also important on large batch jobs, even if they occur in a single transaction. T
        he batch job can be slit into smaller batches within the same transaction and clear can be
        called in between each batch to avoid the persistence context from getting too big.

Learning: An EntityManger contains the Persistence context for a managed object.
    JPA defines 2 states of persistent object: managed vs detached
    managed: managed by an EntityManager
    detached: not managed by an entity Manager
    for a detached object, calling persist(object)  or merge(object) will make the object managed
    call clear(), detach(), remove() after a flush() or commit() will change  the object state to unmanaged


Learning: Embedded entity are entities that associated with an @Entity

Learning: an object should only be managed by 1 EntityManager, otherwise confusion.
    A managed object should only ever reference other managed objects,
    and a detached object should only reference other detached objects.

LEARNING: DAO vs Repository: DAO is data persistence layer. Repository is collection-level
    info closer to teh business-logic layer. Repository may use DAO to persist the info


LEARNING: JPA Bootstrapping: should always use JPA conformant bootstrapping instead
    of Hibernate
    EntityManagerFactory produces EntityManager
    Approach 1: EE approach -> a container injects persistence context into application
    Approach 2: SE Approach -> everything else (Application-bootstrapping)
    _
    Approach 1: (Container-bootstrapping)
        1. each named Persistence Unit defined in META-INF/persistence.xml config
            mark an object as EntityManagerFactory using @PersistenceUnit

LEARNING: -3 Inheritance Mapping strategy
    1. table per hierarchy (1 table for entire inheritance tree), requires:
       1.  @Inheritance(strategy=InheritanceType.SINGLE_TABLE) on parent class
       2.  @DiscriminatorColumn on parent class to say what column in db is added to distinguish
            (on parent class: @DiscriminatorColumn(name="type",discriminatorType=DiscriminatorType.STRING)
       3. @DiscriminatorValue on all classes (parent and child)
            ex: @DiscriminatorValue(value="employee")
    2. table per concrete class, requires:  (duplicate parent columns in subclass tables)
        1. @Inheritance(strategy = InheritanceType.TABLE_PER_CLASS) in parent class only
        2. @AttributeOverrides in subclasses (attributes you want to inherit from the parent)
            these columns from the parent class are added(inherited) to columns of the subclass
            example:
                    @AttributeOverrides({
                        @AttributeOverride(name="id", column=@Column(name="id")),
                        @AttributeOverride(name="name", column=@Column(name="name"))
                    })
        each inherited class need to use @DiscriminatorValue("classColumnUnique")
    3. Most elegant/preferred: table per Subclass, requires
        1. @Inheritance(strategy=InheritanceType.JOINED) in the parent class
        2. @PrimaryKeyJoinColumn annotation in the subclasses, you don't need it in the parent class
            example: @PrimaryKeyJoinColumn(name="ID")  : the parent column ID is joined with this subclass
    for all three method: you need to add these classes to the config file


    Summary: required:
        1. parent class: You put @Inheritance(strategy=?) , @DiscriminatorColumn for table per hierarchy
        2. child class: @DiscriminatorValue(TPH), @AttributeOverrides(tpcc), @PrimaryKeyJoinColumn(TPS)
        3. parent and child class: added to Config file

LEARNING: put to practice: Associations describe
                 how two or more entities form a relationship based on a database joining semantics.
             -4 Collection Mappings
             1. OneToMany
                 one the collection field:
                 @OneToMany(cascade = CascadeType.ALL)
                 @JoinColumn(name="qid")
                 @OrderColumn(name="type")
             2. ManyToOne
                 the target Object that many are associated with: like one company address used by Many Employees
                 this is annotated on top of Address
                   @ManyToOne(cascade=CascadeType.ALL)
                 on the many objects that to the Single Object
                   @OneToOne(cascade=CascadeType.ALL)
             3. OneToOne
                 on both classes being mapped
                 @OneToOne(targetEntity=Address.class,cascade=CascadeType.ALL)
                 @OneToOne(targetEntity=Employee.class)
             4 ManyToMany
                 on one of the objects:
                 @ManyToMany(targetEntity = Answer.class, cascade = { CascadeType.ALL })
                 @JoinTable(name = "q_ans1123",
                             joinColumns = { @JoinColumn(name = "q_id") },
                             inverseJoinColumns = { @JoinColumn(name = "ans_id") })


LEARNING: Spring framework,
    Spring has 3 main components that are exposed through the use of Annotations:
        -Controller Annotations (Route Request and response for business logic processing) (@Controller)
        -Service Annotations  (business logic processing - actions ) (@Service)
        -Repository Annotations (@Repository - data persistence with database)

LEARNING: JPQL is NOT SQL. JPQL is query language written from the perspective of Java Objects,
            whereas SQL is written from a database object perspective
            SQL: "select * from goals", JPQL: "select g from Goals g"

LEARNING: JPA is a specification for accessing, persisting, and managing data between Java Objects and a relational
            database. It has a sql-like language call JPQL - java persistence query language

LEARNING: HQL is super set of JPQL
            A JPQL query is always a valid HQL query, the reverse is not true, however.

LEARNING: Hibernate is used to map Java Objects to Relational databases. There is only a mediocre solution because of
    fundamental Object-Relational Impedance Mismatch principal.  There will always be gaps in the mapping that leads
    to less elegant solutions.
    nevertheless it is used in the industry, thus I must be familiar with this technique. and learn-ing should continue.
    There are competing solutions such using NoSql database.  As part of training, I should see how using NoSql can
    solve this Object-to-Persistence problem.

LEARNING:  In Brief: Advantages and Disadvantages of Using ORM
     FOR:
         -let the developer think in terms of objects rather than tables
         -no need to write SQL code
         -many advanced features like lazy loading
         -database independent: No need to write code specific to a particular database
         -reduces code and allows developers to focus on their business logic, rather than complex database queries
         -various ORMs provide a rich query interface
     AGAINST:
         -complex (because they handle a bidirectional mapping). Their complexity implies a grueling learn-ing curve â€“
         they have a special query language which developers have to learn
         -provides only a leaky abstraction over a relational data store
         -usually systems using an ORM perform badly (due to naive interactions with the underlying database)
         -ORM, by adding a layer of abstraction, speeds up the development but adds overhead to the application

LEARNING: ORM only provides a **leaky*** abstraction over a relational data store, meaning it is not a completion
            solution
          usually systems using an ORM perform badly (due to naive interactions with the underlying database)


LEARNING: When to USE ORM
        SAY YES TO ORM:
          it is intended for OLTP applications  (transaction orientated, small batches)
        SAY NO TO ORM:
          not intended for batch processing (large set of data being transacted, like bulk transformations)
          not recommended where there is a need to perform huge analysis

LEARNING: NoSql
    problem is that NoSql is not standardized, you have to learn new language with different vendors. Where as SQL
    is standardized across the industry
    NoSql is usually distributed Database, make it difficult to integrate to simple apps
    Most NoSql don't need to support transactions
